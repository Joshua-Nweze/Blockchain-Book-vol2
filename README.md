## I cover all aspects of Blockchain from basic to advanced

# Writer Intro
## I am **[Subham Maity](https://subham-maity.github.io/subham/)**
I love Programming. One of the aims I had when I started ```CodeXam``` was to make learning programming easy.
******************
# Chapter in This Documentation:
* [**1. Why should we study Blockchain?**](#why-should-we-study-blockchain)
* [**2. What is Blockchain Technology?**](#what-is-blockchain-technology)
* [**3. Applications of Blockchain Technology**](#applications-of-blockchain-technology)
* [**4. Blockchain Hashing Algorithm**](#blockchain-hashing-algorithm)
* [**5. Hashing with SHA-256**](#hashing-with-sha-256)

******************
******************
******************


# Why should we study Blockchain?

**Look at the image of 2008 financial crisis**

<p align="center">
        <img src="https://github.com/Subham-Maity/Blockchain-Book-vol2/blob/master/Image%20Ignore/2.jpg?raw=true " width="400px"/>
        </p>


**What was the root cause of the global financial crisis in 2008?**

The Biggest Culprit: The Lenders

Most of the blame is on the mortgage originators or the lenders. That's because they were responsible for creating these problems. After all, the lenders were the ones who advanced loans to people with poor credit and a high risk of default

The Global Financial Crisis of 2007-2008 had far-reaching impacts. It catalyzed an implosion of trust in a number of institutions: the commercial banks whose business practices caused the crisis; the central banks that never saw it coming; and the governments that failed to address it effectively or hold the most irresponsible and negligent individuals to account. Indeed, much of the wrongdoing would never have come to light without citizen journalists and whistleblowers. The drawbacks of centralized power became more evident, as did the power of technology.


So we can say ...

<p align="center">
                <img src="https://github.com/Subham-Maity/Blockchain-Book-vol2/blob/master/Image%20Ignore/1.png?raw=true "width="300"/>
                </p>



### Identify the reason why blockchain is the best solution for the future ?

Whenever we purchase something from any website, what do we know, that it will be the same item from the same shop that we ordered. If we donate to any NGO, can we be sure that money is going to that NGO and not to any other? Who is giving that guarantee?

For that purpose, blockchain is the best solution. It is a decentralized system that allows us to store and share data without any middlemen. We are going to share many things later on.

# What is Blockchain Technology?

### Who invented blockchain in 1991?
Stuart Haber and W. Scott Stornetta envisioned what many people have come to know as blockchain, in 1991. Their first work involved working on a cryptographically secured chain of blocks whereby no one could tamper with timestamps of documents.

<p align="center">
                <img src="https://github.com/Subham-Maity/Blockchain-Book-vol2/blob/master/Image%20Ignore/3.png?raw=true " width="300px" />
                </p>

### Satoshi Nakamoto ?

Nakamoto was the one who mined the first blockchain of Bitcoin and was the one who published the whitepaper for the digital currency. Nakamoto had envisioned Bitcoin to be a token of transaction that would be widely adopted by the world to protect against inflation.


<p align="center">
        <img src="https://github.com/Subham-Maity/Blockchain-Book-vol2/blob/master/Image%20Ignore/4.gif?raw=true "width="300px"/>
        </p>


### What is Blockchain Technology?

<p align="center">
        <img src="https://github.com/Subham-Maity/Blockchain-Book-vol2/blob/master/Image%20Ignore/5.gif?raw=true "  width="400px"/>
        </p>

Blockchain is a distributed ledger that is a collection of records, called blocks, that are linked together by cryptography.


### Example of Blockchain in Real Life

<p align="center">
        <img src="https://github.com/Subham-Maity/Blockchain-Book-vol2/blob/master/Image%20Ignore/6.gif?raw=true "  width="200px"/>
        </p>


Let's say I purchase something from an offline store, and I have a ledger in which I can record the details of the purchase, and that ledger was created by the store. Now if the shopkeeper manipulates the ledger, I can't do anything.


But in the case of blockchain, Shopkeeper can't manipulate the ledger, because the ledger is linked to the blockchain ,and it is immutable.If the shopkeeper try to manipulate the ledger, you can easily find out someone is trying to tamper with the ledger ,and you can easily stop him.

# Applications of Blockchain Technology 

### 1. Product Tracking

Blockchain could also help verify the authenticity of imported raw
materials, such as nuts, cocoa and coffee. "In Denmark, we don't have good
documentation of raw materials we import," Høgh Jensen explained. This is
because long supply chains-where food manufacturers are purchasing
from suppliers rather than primary producers-don't always come with
detailed documentation.

For that reason, blockchain could be used to track the raw materials

**The Technical University of Denmark is developing blockchain solutions for small and medium-sized food manufacturers in an effort to combat food fraud in high-value products.**

### 2. Smart Contracts

<p align="center">
        <img src="https://github.com/Subham-Maity/Blockchain-Book-vol2/blob/master/Image%20Ignore/7.gif?raw=true "  width="200px"/>
        </p>

- smart contracts are a set of rules that are executed by a smart contract

- smart contracts are run on the ethereum blockchain

#### Real World Example
<p align="center">
        <img src="https://github.com/Subham-Maity/Blockchain-Book-vol2/blob/master/Image%20Ignore/8.jpg?raw=true "  width="200px"/>
        </p>
The shop looks like this – you pay first and then the guy hands you your stuff.

You pay him for the instant noodles, and you find that the shopkeeper just sits back down on his chair and does nothing.

* “Give me the noodles!”

* “Sure, that’ll be ₹20.”

* “I just paid you!”

* “When? No, you didn’t.”

Other than calling the police or starting a fight, you would have no recourse.
<p align="center">
        <img src="https://github.com/Subham-Maity/Blockchain-Book-vol2/blob/master/Image%20Ignore/9.gif?raw=true "  width="200px"/>
        </p>

The problem here was that you had to trust a human to do his part after you did yours.

While people generally do their part in an implied contract like this one (the contract here was “I give you the stuff after you pay me”), relying on humans to be honest is not an ironclad solution and people get cheated every once in a while.

(Note: Smart contract is just a marketing term for computer programs. It has absolutely nothing to do with a legal contract. Do not relate smart contracts with contracts in a legal sense.)

You would preferably want to take away this element of having to trust this shopkeeper to hold his end of the bargain.

You want to use a system that takes your money and then gives you what you want for sure (a type of contract where you don’t have to trust anybody).

Here, it would be a vending machine.

<p align="center">
        <img src="https://github.com/Subham-Maity/Blockchain-Book-vol2/blob/master/Image%20Ignore/10.gif?raw=true "  width="200px"/>
        </p>


You can buy as many canned slow poisons as you want without having to trust anybody.

You put your money in, you get the stuff you want. You don’t put your money in, you don’t get the stuff you want. You put extra money in, you get change.

You don’t have to trust anybody – it’s an automatic machine that does as it’s programmed to do and nothing else.

(To those of you thinking, what if the machine is malfunctioning – these are all vagaries of the real world. In the world of code, you don’t have to think about this. The program will execute exactly as written.)

The vending machine is a real world example of a smart contract.

It is a software (in this case, real world machinery) executing its code (in this case, giving you the item when you put in money).

That’s it: A smart contract is just a fancy word for a piece of code that automatically executes something in a predetermined way. This piece of code is stored and executed in a distributed/decentralized manner (more on that later).

They are mainly used to reduce the need for a trusted intermediary, disputes, and frauds.

I repeat: it has nothing to do with contracts in the legal sense.

In fact, smart contracts aren’t smart at all. They are just pieces of code that execute exactly as written. For example, if a well-known billionaire is extremely thirsty and offers to pay a million dollars for a drink, it would be smart to take it. But… the vending machine won’t take it, because it hasn’t been explicitly programmed to do so. 

### 3. International Wire Transfer

#### Disadvantages of the centralized banking system:
- Huge fees while transferring money from one bank to another (e.g. $10 for every $1 transferred)
- Time taken to transfer money is long

#### How Blockchain Could Disrupt Banking
Blockchain technology offers a secure and cheap way of sending payments that cuts down on the need for verification from third parties and beats processing times for traditional bank transfers. 90% of members of the European Payments Council believe blockchain technology will fundamentally change the industry by 2025

**Example:** 

Taipei, April 12, 2021 – Global financial services firm J.P. Morgan today announced that it is using blockchain technology to improve funds transfers between banking institutions globally, including payments originating from Taiwan banks to beneficiary banks in other markets. Through improved information exchange related to such payments, the new solution called Confirm is expected to help reduce the number of rejected or returned transactions caused by mismatched payment details, lowering costs for both the sending and receiving banks.

### 4. Healthcare System

Blockchain can be a perfect technology for record-keeping in the medical world. Its applications include sharing healthcare data, keeping electronic healthcare records, managing insurance, and performing administrative tasks. Patients can send their health information via an app to a Blockchain Network.


if that patient store his all medical issue related data store in one block and can be accessed by other hospital and doctor then it save many times and cost.


# Blockchain Hashing Algorithm

<p align="center">
        <img src="https://github.com/Subham-Maity/Blockchain-Book-vol2/blob/master/Image%20Ignore/12.png?raw=true "  width="200px"/>
        </p>

A hash function takes an input string (numbers, alphabets, media files) of any length and transforms it into a fixed length. The fixed bit length can vary (like 32-bit or 64-bit or 128-bit or 256-bit) depending on the hash function which is being used. The fixed-length output is called a hash. This hash is also the cryptographic byproduct of a hash algorithm. We can understand it from the following diagram.


<p align="center">
        <img src="https://github.com/Subham-Maity/Blockchain-Book-vol2/blob/master/Image%20Ignore/13.png?raw=true "  width="200px"/>
        </p>

The hash algorithm has certain unique properties:

- It produces a unique output (or hash).
- It is a one-way function.


In the context of cryptocurrencies like Bitcoin, the blockchain uses this cryptographic hash function's properties in its consensus mechanism. A cryptographic hash is a digest or digital fingerprints of a certain amount of data. In cryptographic hash functions, the transactions are taken as an input and run through a hashing algorithm which gives an output of a fixed size. The output is called a hash. The hash is then used to verify the integrity of the transaction.'

## SHA-256
A Bitcoin's blockchain uses SHA-256 (Secure Hash Algorithm) hashing algorithm. In 2001, SHA-256 Hashing algorithm was developed by the National Security Agency (NSA) in the USA.
## How does the hashing process works?
Use this website to understand how the hashing process works:

https://passwordsgenerator.net/sha256-hash-generator/

If we type any character in the data section, we will observe its corresponding cryptographic hash in the hash section.
For example: We have type in data section: This is a great tutorial.

It will generate the corresponding Hash:

```
88FBF3D99F89E1252E3FD89FDF4DDEBB474D419237635555222C1905425F08DF
```

<p align="center">
        <img src="https://github.com/Subham-Maity/Blockchain-Book-vol2/blob/master/Image%20Ignore/14.png?raw=true "  width="200px"/>
        </p>

Now if we change the text: "This is a great tutorial." To "this is a great tutorial."

You will find the corresponding Hash:
```
6EED417FA02389F499D3A238AB8365509B21CB65C134A4A7DC8DB1B185C7AEFB
```
In the above, you can see that we have changed only the first character case sentence from capital "T" to small "t" and it will change the whole Hash value.

Since the Hash function is a one-way function, there is no way to get back entire text from the generated hash. This is different from traditional cryptographic functions like encryption where you can encrypt something using the key and by using decryption, you can decrypt the message to its original form.


# Hashing with SHA-256 
Hash functions transform arbitrary large bit strings called messages, into small, fixed-length bit strings called message digests, such that digests identify the messages that produced them with a very high probability. Digests are in that sense fingerprints: a function of the message, simple, yet complex enough that they allow identification of their message, with a very low probability that different messages will share the same digests.

In SHA-256, messages up to 2⁶⁴ bit (2.3 exabytes, or 2.3 billion gigabytes) are transformed into digests of size 256 bits (32 bytes). For perspective, this means that an object 7 times the size of Facebook’s data warehouse in 2014 passed to SHA-256 would produce a chunk of data the size of a 32-letter string of ASCII characters, and that string would the object’s very special fingerprint.

<p align="center">
        <img src="https://github.com/Subham-Maity/Blockchain-Book-vol2/blob/master/Image%20Ignore/15.png?raw=true "  width="200px"/>
        </p>

If we note Bⁿ the set of all bit strings of length strictly n, then we can define SHA-256 as a function from the union of bit strings sets B¹ to B²^⁶⁴, i.e. taking as input any message M of length less than 2⁶⁴, mapping to the bit string set B²⁵⁶, i.e. outputting digests H of length strictly 256.

A prominent use case of hashing is data integrity verification of large files, which relies on the comparison of actual and expected message digests, or checksums. Another is hashing as part of the encryption/decryption journey. Before a message can be encrypted with an algorithm like RSA, it needs to be hashed. In the rest of this article, we explore what hashing does to a message, with a view to later develop a better understanding of RSA.

## Step by step hashing with SHA-256

### Pre-processing

1. Padding. If we note M the message to be hashed, and l its length in bits where l < 2⁶⁴, then as a first step we create the padded message M’, which is message M plus a right padding, such that M’ is of length l’, a multiple of 512. Specifically, we use a padding P such that M’ is:


<p align="center">
        <img src="https://github.com/Subham-Maity/Blockchain-Book-vol2/blob/master/Image%20Ignore/16.png?raw=true "  width="200px"/>
        </p>

The new message M’=M‖P is of length l’, a multiple of 512. The inclusion of L in padding P helps avoid trivial collisions (i.e. messages “00” and “000” would produce identical padded messages in the absence of L). The original message can be extracted by reading the last 64 for bits for length, and then fetching the message from left to right, of length l.

2. Blocks. M’ is parsed into N blocks of size 512 bits, M¹ to Mᴺ, and each block is expressed as 16 input blocks of size 32 bits, M₀ to M₁₅.
 
<p align="center">
        <img src="https://github.com/Subham-Maity/Blockchain-Book-vol2/blob/master/Image%20Ignore/17.png?raw=true "  width="200px"/>
        </p>

Each block contains 16 input blocks, numbered from 0 to 15 in every block

3. Hash initialization. The initial hash value H⁰ of length 256 bits (8 input blocks of 32 bits) is set by taking the first 32 bits of the fractional parts of the square roots of the first eight prime numbers:

<p align="center">
        <img src="https://github.com/Subham-Maity/Blockchain-Book-vol2/blob/master/Image%20Ignore/18.png?raw=true "  width="200px"/>
        </p>
The eight input blocks of the initial has value H, in hexadecimal notation

Those values can be reproduced with the below snippet in most browsers and Node ≥8.2.1 (ECMAScript 2017):

```

for (i of [2, 3, 5, 7, 11, 13, 17, 19]) {
  input_block = parseInt((Math.sqrt(i) % 1).toString(2).slice(2, 34), 2);
  console.log(input_block.toString(16), input_block.toString(2).padStart(32, '0'));
}
```

**Algorithm**

The hash is produced by processing each message block Mⁱ of M’ in order. For each of message block Mⁱ:

1. Message schedule. We create a message schedule Wⁱ, consisting of four 512-bit message blocks (each made of 16 input blocks). The first block of Wⁱ is message block Mⁱ, and the next three blocks are variations of Mⁱ, obtained through the formulas in the illustration below:

<p align="center">
        <img src="https://github.com/Subham-Maity/Blockchain-Book-vol2/blob/master/Image%20Ignore/19.png?raw=true "  width="200px"/>
        </p>

In the formulas, t refers to the ‘input block’ number, ranging from 0 to 63. The input blocks of the ‘shuffled blocks’ are functions of prior input blocks, and are generated with special functions, mixing right rotations (ROTR), right shifts (SHR) and exclusive ORs (⊕). Those operations are introduced in a previous article on Bitwise Patterns.

A detail: note that if we align all message schedules Wⁱ vertically, the first column reads from top to bottom as the complete message M’ = M¹‖..‖Mᴺ.


2. The big shuffle. The input blocks of message schedule W are fed, one after the other, to a function represented below as a graph. The graph takes as inputs a hash ωⁱ(t) and a message schedule input block Wⁱ(t), and outputs a hash ωⁱ(t+1). The initial hash ωⁱ(0) fed to the graph is the intermediate hash Hⁱ⁻¹: in the case of W¹, it’s H⁰ defined in the pre-processing step. ωⁱ(0) and Wⁱ(0) produce ωⁱ(1); in turn ωⁱ(1) and Wⁱ(1) produce ωⁱ(2), etc., until ωⁱ(63) is produced.

<p align="center">
        <img src="https://github.com/Subham-Maity/Blockchain-Book-vol2/blob/master/Image%20Ignore/12.gif?raw=true "  width="200px"/>
        </p>

A visual representation the transformations operated on H⁰ using input blocks from the message schedule W. The operation must be repeated 64 times until ω(63) is produced.

<p align="center">
        <img src="https://github.com/Subham-Maity/Blockchain-Book-vol2/blob/master/Image%20Ignore/20.png?raw=true "  width="200px"/>
        </p>

The official loop as seen in FIPS 180–4. a, .., h are initialized as Hi⁻¹(0), .., Hi⁻¹(7). Sigma0, Sigma1, Ch, and Maj are functions using AND, XOR and negations; K is a bit word with 64 input blocks.

3. New hash. After all input blocks from Wⁱ have been used and we ω(63) has been created, we can create the new hash Hⁱ such that each input block of Hⁱ is the sum of the corresponding input block of Hⁱ⁻¹ plus the corresponding input block of ωⁱ(63):

Hⁱ(j) = Hⁱ⁻¹(j) + ωⁱ(63)(j) where + is the addition modulo 2ⁿ

If other message blocks Mⁱ remain, repeat the process (message schedule, big shuffle, creation of the new hash Hⁱ)

If Wⁱ was the last message schedule, then Hⁱ = H is message M’s final hash or digest — its so very special fingerprint.

This concludes the overview of SHA-256 as described in FIPS 180–4. A few closing thoughts:

SHA-256 projects into B²⁵⁶, a space of ~1e77 possible values, which is lots of potential digests: a good thing that provides the intuition that collisions are unlikely
That being said, we do not prove here that collisions are unlikely, we even know they exist given the surjective nature of the hashing function. We know however that (i) given a limited amount of things to hash, we’re unlikely to find collisions (ii) no collisions have been found to date for SHA-256.
Finally, coding your own SHA-256 for production use is probably not a good idea…
…but just for fun and education purposes, here is a version I wrote in JavaScript.

```js
'use strict';

(function (shs) {

  const H0 = [
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,
  ];

  const K = [
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,
  ];

  /**
   * Rotate to right
   * @param {number} x - An integer to be shifted right
   * @param {number} n - The number of bits by which to shift
   * @param {string} [w] - The bit notation width. Defaults to x.toString(2).length
   * @return {number} The shifted number
   */
  function rotr(x, n, w) {
    if (!w) { var w = x.toString(2).length; }
    n = n % w;
    return (((x >>> n) | (x << w - n)) >>> 0) % Math.pow(2, w);
  };

  /**
   * Rotate to left
   * @param {number} x - An integer to be shifted right
   * @param {number} n - The number of bits by which to shift
   * @return {number} The shifted number
   */
  function rotl(x, n) {
    let w = x.toString(2).length;
    n = n % w;
    return (((x << n) | (x >>> w - n)) >>> 0) % Math.pow(2, w);
  };

  /**
   * SHA-256 logical functions
   */
  function Ch(x, y, z) { return (x & y) ^ (~x & z); };

  function Maj(x, y, z) { return (x & y) ^ (x & z) ^ (y & z); };

  function Σ0(x) { return rotr(x, 2, 32) ^ rotr(x, 13, 32) ^ rotr(x, 22, 32); };

  function Σ1(x) { return rotr(x, 6, 32) ^ rotr(x, 11, 32) ^ rotr(x, 25, 32); };

  function σ0(x) { return rotr(x, 7, 32) ^ rotr(x, 18, 32) ^ (x >>> 3); };

  function σ1(x) { return rotr(x, 17, 32) ^ rotr(x, 19, 32) ^ (x >>> 10); };

  /**
   * Padding
   * @param {string} m - The message, a binary string (e.g., 011010)
   * @return {string} A padded message
   */
  function pad(m) {
    if (m.length > Math.pow(2, 64)) {
      return console.error('Message out of range.');
    }

    let padding1 = '0'.repeat(512 - ((m.length + 1 + 64) % 512));
    let padding2 = '0'.repeat(64 - m.length.toString(2).length);
    return `${m}1${padding1}${padding2}${m.length.toString(2)}`;
  }

  /**
   * Parse
   * @param {string} paddedMessage - A padded message of length N x 512
   * @return {array} An array containing 512 segments, further split in 32-bit segments
   * expressed as numbers
   */
  function parse(m) {
    let M = m.match(/[0-1]{512}/g);

    return M.map((x) => {
      let arr = x.match(/[0-1]{32}/g);
      return arr.map((x) => {
        return parseInt(x, 2);
      });
    });
  };

  /**
   * Hash
   * @param {string} m - A binary string to be hashed
   * @return {string} A SHA-256 digest
   */
  shs.hash = function (m) {

    // Pre-processing
    let M = parse(pad(m));

    // Initialize the hash
    let H = [H0];

    // Hash computation
    for (let i = 0, N = M.length; i < N; i++) {

      // Prepare the message schedule
      let W = [];
      for (let t = 0; t < 64; t++) {
        if (t <= 15) {
          W[t] = M[i][t];
        } else {
          W[t] = (σ1(W[t - 2]) + W[t - 7] + σ0(W[t - 15]) + W[t - 16]) % Math.pow(2, 32);
        }
      }

      // Initialize the working variables
      let a = H[i][0];
      let b = H[i][1];
      let c = H[i][2];
      let d = H[i][3];
      let e = H[i][4];
      let f = H[i][5];
      let g = H[i][6];
      let h = H[i][7];
      let T1;
      let T2;

      // Do stuff
      for (let t = 0; t < 64; t++) {
        T1 = (h + Σ1(e) + Ch(e, f, g) + K[t] + W[t]) % Math.pow(2, 32);
        T2 = (Σ0(a) + Maj(a, b, c)) % Math.pow(2, 32);
        h = g;
        g = f;
        f = e;
        e = (d + T1) % Math.pow(2, 32);
        d = c;
        c = b;
        b = a;
        a = (T1 + T2) % Math.pow(2, 32);
      }

      // Compute the i-th intermediate hash
      H[i + 1] = [];
      H[i + 1][0] = (a + H[i][0]) % Math.pow(2, 32);
      H[i + 1][1] = (b + H[i][1]) % Math.pow(2, 32);
      H[i + 1][2] = (c + H[i][2]) % Math.pow(2, 32);
      H[i + 1][3] = (d + H[i][3]) % Math.pow(2, 32);
      H[i + 1][4] = (e + H[i][4]) % Math.pow(2, 32);
      H[i + 1][5] = (f + H[i][5]) % Math.pow(2, 32);
      H[i + 1][6] = (g + H[i][6]) % Math.pow(2, 32);
      H[i + 1][7] = (h + H[i][7]) % Math.pow(2, 32);
    }

    let digestWords = H[M.length];
    let digestTemp = digestWords.map((x) => {
      let hex = (x >>> 0).toString(16);
      return `${'0'.repeat(8 - hex.length)}${hex}`;
    });

    let digest = digestTemp.join('');
    return digest;
  };

  /**
   * Hash a UTF-8 string
   * @param {string} string - A string, encoded using UTF-8
   * @return {string} A SHA-256 digest
   */
  shs.hashString = function (str) {
    return shs.hash(helpers.toUTF8OctetString(str).replace(/ /g, '')); // remove whitespqces
  }

}(window.shs = window.shs || {}));
```


```js
'use strict';

(function (helpers) {

  /**
   * Converts binary code point into a UTF-8 binary string
   * @param {number} codepoint - A Unicode codepoint as a number
   * @return {string} The UTF-8 binary string for that codepoint
   */
  function codePointToUtf8BinaryNotation(codePoint) {

    const str = codePoint.toString(2);
    const len = str.length;

    // 0xxxxxxx
    if (len <= 7) {
      let padding = '0'.repeat(7 - len);
      return `0${padding}${str}`;
    }

    // 110xxxxx 10xxxxxx
    else if (len <= 11) {
      let padding = '0'.repeat(11 - len);
      return `110${padding}${str.slice(0, -6)} 10${str.slice(-6)}`;
    }

    // 1110xxxx 10xxxxxx 10xxxxxx
    else if (len <= 16) {
      let padding = '0'.repeat(16 - len);
      return `1110${padding}${str.slice(0, -12)} 10${str.slice(-12, -6)} 10${str.slice(-6)}`;
    }

    // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
    else if (len <= 21) {

      // Special case where bits can still fit in the last 3 octets
      if (len == 17) {
        return `11110000 100${str.slice(0, -12)} 10${str.slice(-12, -6)} 10${str.slice(-6)}`;
      }

      let padding = '0'.repeat(21 - len);
      return `11110${padding}${str.slice(0, -18)} 10${str.slice(-18, -12)} 10${str.slice(-12, -6)} 10${str.slice(-6)}`;
    }

    // Error
    else {
      console.error('Did not receive a valid Unicode binaryNotation');
    }

  };

  /**
   * Converts a human-readble string into a UTF-8 binary string
   * @param {string} str - A human-readable string
   * @return {string} An octet string
   */
  helpers.toUTF8OctetString = function (str) {
    let octetStringArray = [];

    // Use for..of to avoid counting of surrogate pairs
    // see: https://mathiasbynens.be/notes/javascript-unicode
    for (let symbol of str) {

      let codePoint = symbol.codePointAt(0);
      let utf8BinaryNotation = codePointToUtf8BinaryNotation(codePoint);

      octetStringArray.push(utf8BinaryNotation);
    };

    return octetStringArray.join(' ');

  };

  /**
   * Converts a UTF-8 octet string in human-readable formate
   * @param {string} str - A UTF-8 octet string in binary format
   * @return {string} A human-readable string
   */
  helpers.fromUTF8OctetString = function (str) {
    let octetStringArray = str.split(' ');
    let i = 0;
    let output = [];

    while (i < octetStringArray.length) {

      // 0xxxxxxx
      if (octetStringArray[i].slice(0, 1) == '0') {
        let codeUnit = octetStringArray.slice(i, i + 1).join(' ');
        let codePointBin = codeUnit.slice(1);
        let codePoint = parseInt(codePointBin, 2);
        output.push(String.fromCodePoint(codePoint));
        i += 1;
      }

      // 110xxxxx 10xxxxxx
      else if (octetStringArray[i].slice(0, 3) == '110') {
        let codeUnit = octetStringArray.slice(i, i + 2).join(' ');
        let codePointBin = `${codeUnit.slice(3, 8)}${codeUnit.slice(11)}`;
        let codePoint = parseInt(codePointBin, 2);
        output.push(String.fromCodePoint(codePoint));
        i += 2;
      }

      // 1110xxxx 10xxxxxx 10xxxxxx
      else if (octetStringArray[i].slice(0, 4) == '1110') {
        let codeUnit = octetStringArray.slice(i, i + 3).join(' ');
        let codePointBin = `${codeUnit.slice(4, 8)}${codeUnit.slice(11, 17)}${codeUnit.slice(20)}`;
        let codePoint = parseInt(codePointBin, 2);
        output.push(String.fromCodePoint(codePoint));
        i += 3;
      }

      // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
      else if (octetStringArray[i].slice(0, 5) == '11110') {
        let codeUnit = octetStringArray.slice(i, i + 4).join(' ');
        let codePointBin = `${codeUnit.slice(4, 8)}${codeUnit.slice(11, 17)}${codeUnit.slice(20, 26)}${codeUnit.slice(29)}`;
        let codePoint = parseInt(codePointBin, 2);
        output.push(String.fromCodePoint(codePoint));
        i += 4;
      }

      // Else, there is an error
      else {
        return console.error('Unexpected UTF-8 octet');
      }

    }

    return output.join('');
  };


}(window.helpers = window.helpers || {}));
```
# Avalanche Effect in Cryptography
In cryptography, the avalanche effect is a term associated with a specific behavior of mathematical functions used for encryption. Avalanche effect is considered as one of the desirable property of any encryption algorithm. A slight change in either the key or the plain-text should result in a significant change in the cipher-text. This property is termed as avalanche effect.

In simple words, it quantifies the effect on the cipher-text with respect to the small change made in plain text or the key. 
<p align="center">
        <img src="https://github.com/Subham-Maity/Blockchain-Book-vol2/blob/master/Image%20Ignore/21.png?raw=true "  width="200px"/>
        </p>

Even though the concept of avalanche effect was identified by “Shannon’s property of confusion”, the term was first mentioned by Horst Feistel. To implement a strong cipher or cryptographic hash function, this should be considered as one of the primary design objective.

In case of algorithm that uses hash value, even a small alteration in an input string should drastically change the hash value. In other words, flipping single bit in input string should at least flip half of the bits in the hash value.

A good encryption algorithm should always satisfy the following relation: 

```
Avalanche effect > 50% 
```

The effect ensures that an attacker cannot easily predict a plain-text through a statistical analysis. An encryption algorithm that doesn’t satisfies this property can favor an easy statistical analysis. That is, if the alteration in a single bit of the input results in change of only single bit of the desired output, then it’s easy to crack the encrypted text.

**Examples:**


**Example-1:** Avalanche effect in cryptography refers

(A) Large changes in cipher text when the keyword is changed minimally

(B) Large changes in cipher text when the plain text is changed

(C) Large impact of keyword change to length of the cipher text

(D) None of the above

Answer: (A)

**Example-2:** Avalanche effect in cryptography

(A) Is desirable property of cryptographic algorithm

(B) Is undesirable property of cryptographic algorithm

(C) Has no effect on encryption algorithm

(D) None of the above

Answer: (A) 

# Blockchain Immutable Ledger