<!DOCTYPE html>
<html lang="en">
<head>
        <meta charset="UTF-8">


        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Document</title>
        <link href="https://fonts.googleapis.com/css2?family=Potta+One&family=Roboto:wght@100&display=swap"
              rel="stylesheet">
        <link rel="stylesheet" href="prism.css">
        <script src="prism.js"></script>
        <link rel="stylesheet" href="style.css">
</head>
<body>

<div class="container main">


        <h2 id="i-cover-all-aspects-of-blockchain-from-basic-to-advanced">I cover all aspects of Blockchain from basic to advanced</h2>
        <h1 id="writer-intro">Writer Intro</h1>
        <h2 id="i-am-subham-maity-https-subham-maity-github-io-subham-">I am <strong><a href="https://subham-maity.github.io/subham/">Subham Maity</a></strong></h2>
    <p>I love Programming. One of the aims I had when I started <code>CodeXam</code> was to make learning programming easy.</p>
    <hr>
    <h1 id="chapter-in-this-documentation-">Chapter in This Documentation:</h1>
    <ul>
        <li><a href="#why-should-we-study-blockchain"><strong>1. Why should we study Blockchain?</strong></a></li>
        <li><a href="#what-is-blockchain-technology"><strong>2. What is Blockchain Technology?</strong></a></li>
        <li><a href="#applications-of-blockchain-technology"><strong>3. Applications of Blockchain Technology</strong></a></li>
        <li><a href="#blockchain-hashing-algorithm"><strong>4. Blockchain Hashing Algorithm</strong></a></li>
        <li><a href="#hashing-with-sha-256"><strong>5. Hashing with SHA-256</strong></a></li>
    </ul>
    <hr>
    <hr>
    <hr>
    <h1 id="why-should-we-study-blockchain-">Why should we study Blockchain?</h1>

    <p><strong>Look at the image of 2008 financial crisis</strong></p>
        <p align="center">
                <img src="https://github.com/Subham-Maity/Blockchain-Book-vol2/blob/master/Image%20Ignore/2.jpg?raw=true " width="400px"/>
        </p>


        <p><strong>What was the root cause of the global financial crisis in 2008?</strong></p>
        <p>The Biggest Culprit: The Lenders</p>
        <p>Most of the blame is on the mortgage originators or the lenders. That&#39;s because they were responsible for creating these problems. After all, the lenders were the ones who advanced loans to people with poor credit and a high risk of default</p>
        <p>The Global Financial Crisis of 2007-2008 had far-reaching impacts. It catalyzed an implosion of trust in a number of institutions: the commercial banks whose business practices caused the crisis; the central banks that never saw it coming; and the governments that failed to address it effectively or hold the most irresponsible and negligent individuals to account. Indeed, much of the wrongdoing would never have come to light without citizen journalists and whistleblowers. The drawbacks of centralized power became more evident, as did the power of technology.</p>
        <p>So we can say ...</p>
        <p align="center">
                <img src="https://github.com/Subham-Maity/Blockchain-Book-vol2/blob/master/Image%20Ignore/1.png?raw=true "width="300"/>
        </p>



        <h3 id="identify-the-reason-why-blockchain-is-the-best-solution-for-the-future-">Identify the reason why blockchain is the best solution for the future ?</h3>
        <p>Whenever we purchase something from any website, what do we know, that it will be the same item from the same shop that we ordered. If we donate to any NGO, can we be sure that money is going to that NGO and not to any other? Who is giving that guarantee?</p>
        <p>For that purpose, blockchain is the best solution. It is a decentralized system that allows us to store and share data without any middlemen. We are going to share many things later on.</p>
        <h1 id="2-what-is-blockchain-technology-">What is Blockchain Technology?</h1>
        <h3 id="who-invented-blockchain-in-1991-">Who invented blockchain in 1991?</h3>
        <p>Stuart Haber and W. Scott Stornetta envisioned what many people have come to know as blockchain, in 1991. Their first work involved working on a cryptographically secured chain of blocks whereby no one could tamper with timestamps of documents.</p>
        <p align="center">
                <img src="https://github.com/Subham-Maity/Blockchain-Book-vol2/blob/master/Image%20Ignore/3.png?raw=true " width="300px" />
        </p>

        <h3 id="satoshi-nakamoto-">Satoshi Nakamoto ?</h3>
        <p>Nakamoto was the one who mined the first blockchain of Bitcoin and was the one who published the whitepaper for the digital currency. Nakamoto had envisioned Bitcoin to be a token of transaction that would be widely adopted by the world to protect against inflation.</p>
        <p align="center">
                <img src="https://github.com/Subham-Maity/Blockchain-Book-vol2/blob/master/Image%20Ignore/4.gif?raw=true "width="300px"/>
        </p>


        <h3 id="what-is-blockchain-technology-">What is Blockchain Technology?</h3>
        <p align="center">
                <img src="https://github.com/Subham-Maity/Blockchain-Book-vol2/blob/master/Image%20Ignore/5.gif?raw=true "  width="400px"/>
        </p>

        <p>Blockchain is a distributed ledger that is a collection of records, called blocks, that are linked together by cryptography.</p>
        <h3 id="example-of-blockchain-in-real-life">Example of Blockchain in Real Life</h3>
        <p align="center">
                <img src="https://github.com/Subham-Maity/Blockchain-Book-vol2/blob/master/Image%20Ignore/6.gif?raw=true "  width="200px"/>
        </p>


        <p>Let&#39;s say I purchase something from an offline store, and I have a ledger in which I can record the details of the purchase, and that ledger was created by the store. Now if the shopkeeper manipulates the ledger, I can&#39;t do anything.</p>
        <p>But in the case of blockchain, Shopkeeper can&#39;t manipulate the ledger, because the ledger is linked to the blockchain ,and it is immutable.If the shopkeeper try to manipulate the ledger, you can easily find out someone is trying to tamper with the ledger ,and you can easily stop him.</p>
        <h1 id="applications-of-blockchain-technology">Applications of Blockchain Technology</h1>
        <h3 id="1-product-tracking">1. Product Tracking</h3>
        <p>Blockchain could also help verify the authenticity of imported raw
                materials, such as nuts, cocoa and coffee. &quot;In Denmark, we don&#39;t have good
                documentation of raw materials we import,&quot; Høgh Jensen explained. This is
                because long supply chains-where food manufacturers are purchasing
                from suppliers rather than primary producers-don&#39;t always come with
                detailed documentation.</p>
        <p>For that reason, blockchain could be used to track the raw materials</p>
        <p><strong>The Technical University of Denmark is developing blockchain solutions for small and medium-sized food manufacturers in an effort to combat food fraud in high-value products.</strong></p>
        <h3 id="2-smart-contracts">2. Smart Contracts</h3>
        <p align="center">
                <img src="https://github.com/Subham-Maity/Blockchain-Book-vol2/blob/master/Image%20Ignore/7.gif?raw=true "  width="200px"/>
        </p>

        <ul>
                <li><p>smart contracts are a set of rules that are executed by a smart contract</p>
                </li>
                <li><p>smart contracts are run on the ethereum blockchain</p>
                </li>
        </ul>
        <h4 id="real-world-example">Real World Example</h4>
        <p align="center">
                <img src="https://github.com/Subham-Maity/Blockchain-Book-vol2/blob/master/Image%20Ignore/8.jpg?raw=true "  width="200px"/>
        </p>
        The shop looks like this – you pay first and then the guy hands you your stuff.

        You pay him for the instant noodles, and you find that the shopkeeper just sits back down on his chair and does nothing.

        <em> “Give me the noodles!”

        </em> “Sure, that’ll be ₹20.”

        <em> “I just paid you!”

        </em> “When? No, you didn’t.”

        Other than calling the police or starting a fight, you would have no recourse.
        <p align="center">
                <img src="https://github.com/Subham-Maity/Blockchain-Book-vol2/blob/master/Image%20Ignore/9.gif?raw=true "  width="200px"/>
        </p>

        <p>The problem here was that you had to trust a human to do his part after you did yours.</p>
        <p>While people generally do their part in an implied contract like this one (the contract here was “I give you the stuff after you pay me”), relying on humans to be honest is not an ironclad solution and people get cheated every once in a while.</p>
        <p>(Note: Smart contract is just a marketing term for computer programs. It has absolutely nothing to do with a legal contract. Do not relate smart contracts with contracts in a legal sense.)</p>
        <p>You would preferably want to take away this element of having to trust this shopkeeper to hold his end of the bargain.</p>
        <p>You want to use a system that takes your money and then gives you what you want for sure (a type of contract where you don’t have to trust anybody).</p>
        <p>Here, it would be a vending machine.</p>
        <p align="center">
                <img src="https://github.com/Subham-Maity/Blockchain-Book-vol2/blob/master/Image%20Ignore/10.gif?raw=true "  width="200px"/>
        </p>


        <p>You can buy as many canned slow poisons as you want without having to trust anybody.</p>
        <p>You put your money in, you get the stuff you want. You don’t put your money in, you don’t get the stuff you want. You put extra money in, you get change.</p>
        <p>You don’t have to trust anybody – it’s an automatic machine that does as it’s programmed to do and nothing else.</p>
        <p>(To those of you thinking, what if the machine is malfunctioning – these are all vagaries of the real world. In the world of code, you don’t have to think about this. The program will execute exactly as written.)</p>
        <p>The vending machine is a real world example of a smart contract.</p>
        <p>It is a software (in this case, real world machinery) executing its code (in this case, giving you the item when you put in money).</p>
        <p>That’s it: A smart contract is just a fancy word for a piece of code that automatically executes something in a predetermined way. This piece of code is stored and executed in a distributed/decentralized manner (more on that later).</p>
        <p>They are mainly used to reduce the need for a trusted intermediary, disputes, and frauds.</p>
        <p>I repeat: it has nothing to do with contracts in the legal sense.</p>
        <p>In fact, smart contracts aren’t smart at all. They are just pieces of code that execute exactly as written. For example, if a well-known billionaire is extremely thirsty and offers to pay a million dollars for a drink, it would be smart to take it. But… the vending machine won’t take it, because it hasn’t been explicitly programmed to do so. </p>
        <h3 id="3-international-wire-transfer">3. International Wire Transfer</h3>
        <h4 id="disadvantages-of-the-centralized-banking-system-">Disadvantages of the centralized banking system:</h4>
        <ul>
                <li>Huge fees while transferring money from one bank to another (e.g. $10 for every $1 transferred)</li>
                <li>Time taken to transfer money is long</li>
        </ul>
        <h4 id="how-blockchain-could-disrupt-banking">How Blockchain Could Disrupt Banking</h4>
        <p>Blockchain technology offers a secure and cheap way of sending payments that cuts down on the need for verification from third parties and beats processing times for traditional bank transfers. 90% of members of the European Payments Council believe blockchain technology will fundamentally change the industry by 2025</p>
        <p><strong>Example:</strong> </p>
        <p>Taipei, April 12, 2021 – Global financial services firm J.P. Morgan today announced that it is using blockchain technology to improve funds transfers between banking institutions globally, including payments originating from Taiwan banks to beneficiary banks in other markets. Through improved information exchange related to such payments, the new solution called Confirm is expected to help reduce the number of rejected or returned transactions caused by mismatched payment details, lowering costs for both the sending and receiving banks.</p>
        <h3 id="4-healthcare-system">4. Healthcare System</h3>
        <p>Blockchain can be a perfect technology for record-keeping in the medical world. Its applications include sharing healthcare data, keeping electronic healthcare records, managing insurance, and performing administrative tasks. Patients can send their health information via an app to a Blockchain Network.</p>
        <p>if that patient store his all medical issue related data store in one block and can be accessed by other hospital and doctor then it save many times and cost.</p>
        <h1 id="blockchain-hashing-algorithm">Blockchain Hashing Algorithm</h1>
        <p align="center">
                <img src="https://github.com/Subham-Maity/Blockchain-Book-vol2/blob/master/Image%20Ignore/12.png?raw=true "  width="200px"/>
        </p>

        <p>A hash function takes an input string (numbers, alphabets, media files) of any length and transforms it into a fixed length. The fixed bit length can vary (like 32-bit or 64-bit or 128-bit or 256-bit) depending on the hash function which is being used. The fixed-length output is called a hash. This hash is also the cryptographic byproduct of a hash algorithm. We can understand it from the following diagram.</p>
        <p align="center">
                <img src="https://github.com/Subham-Maity/Blockchain-Book-vol2/blob/master/Image%20Ignore/13.png?raw=true "  width="200px"/>
        </p>

        <p>The hash algorithm has certain unique properties:</p>
        <ul>
                <li>It produces a unique output (or hash).</li>
                <li>It is a one-way function.</li>
        </ul>
        <p>In the context of cryptocurrencies like Bitcoin, the blockchain uses this cryptographic hash function&#39;s properties in its consensus mechanism. A cryptographic hash is a digest or digital fingerprints of a certain amount of data. In cryptographic hash functions, the transactions are taken as an input and run through a hashing algorithm which gives an output of a fixed size. The output is called a hash. The hash is then used to verify the integrity of the transaction.&#39;</p>
        <h2 id="sha-256">SHA-256</h2>
        <p>A Bitcoin&#39;s blockchain uses SHA-256 (Secure Hash Algorithm) hashing algorithm. In 2001, SHA-256 Hashing algorithm was developed by the National Security Agency (NSA) in the USA.</p>
        <h2 id="how-does-the-hashing-process-works-">How does the hashing process works?</h2>
        <p>Use this website to understand how the hashing process works:</p>
        <p><a href="https://passwordsgenerator.net/sha256-hash-generator/">https://passwordsgenerator.net/sha256-hash-generator/</a></p>
        <p>If we type any character in the data section, we will observe its corresponding cryptographic hash in the hash section.
                For example: We have type in data section: This is a great tutorial.</p>
        <p>It will generate the corresponding Hash:</p>
        <pre class="language-js"><code>88FBF3D99F89E1252E3FD89FDF4DDEBB474D419237635555222C1905425F08DF </code></pre>
     <p align="center">
        <img src="https://github.com/Subham-Maity/Blockchain-Book-vol2/blob/master/Image%20Ignore/14.png?raw=true "  width="200px"/>
</p>

        <p>Now if we change the text: &quot;This is a great tutorial.&quot; To &quot;this is a great tutorial.&quot;</p>
        <p>You will find the corresponding Hash:</p>

        <pre class="language-js"><code>6EED417FA02389F499D3A238AB8365509B21CB65C134A4A7DC8DB1B185C7AEFB </code></pre>

        <p>In the above, you can see that we have changed only the first character case sentence from capital &quot;T&quot; to small &quot;t&quot; and it will change the whole Hash value.</p>
        <p>Since the Hash function is a one-way function, there is no way to get back entire text from the generated hash. This is different from traditional cryptographic functions like encryption where you can encrypt something using the key and by using decryption, you can decrypt the message to its original form.</p>
        <h1 id="hashing-with-sha-256">Hashing with SHA-256</h1>
        <p>Hash functions transform arbitrary large bit strings called messages, into small, fixed-length bit strings called message digests, such that digests identify the messages that produced them with a very high probability. Digests are in that sense fingerprints: a function of the message, simple, yet complex enough that they allow identification of their message, with a very low probability that different messages will share the same digests.</p>
        <p>In SHA-256, messages up to 2⁶⁴ bit (2.3 exabytes, or 2.3 billion gigabytes) are transformed into digests of size 256 bits (32 bytes). For perspective, this means that an object 7 times the size of Facebook’s data warehouse in 2014 passed to SHA-256 would produce a chunk of data the size of a 32-letter string of ASCII characters, and that string would the object’s very special fingerprint.</p>
        <p align="center">
                <img src="https://github.com/Subham-Maity/Blockchain-Book-vol2/blob/master/Image%20Ignore/15.png?raw=true "  width="200px"/>
        </p>

        <p>If we note Bⁿ the set of all bit strings of length strictly n, then we can define SHA-256 as a function from the union of bit strings sets B¹ to B²^⁶⁴, i.e. taking as input any message M of length less than 2⁶⁴, mapping to the bit string set B²⁵⁶, i.e. outputting digests H of length strictly 256.</p>
        <p>A prominent use case of hashing is data integrity verification of large files, which relies on the comparison of actual and expected message digests, or checksums. Another is hashing as part of the encryption/decryption journey. Before a message can be encrypted with an algorithm like RSA, it needs to be hashed. In the rest of this article, we explore what hashing does to a message, with a view to later develop a better understanding of RSA.</p>
        <h2 id="step-by-step-hashing-with-sha-256">Step by step hashing with SHA-256</h2>
        <h3 id="pre-processing">Pre-processing</h3>
        <ol>
                <li>Padding. If we note M the message to be hashed, and l its length in bits where l &lt; 2⁶⁴, then as a first step we create the padded message M’, which is message M plus a right padding, such that M’ is of length l’, a multiple of 512. Specifically, we use a padding P such that M’ is:</li>
        </ol>
        <p align="center">
                <img src="https://github.com/Subham-Maity/Blockchain-Book-vol2/blob/master/Image%20Ignore/16.png?raw=true "  width="200px"/>
        </p>

        <p>The new message M’=M‖P is of length l’, a multiple of 512. The inclusion of L in padding P helps avoid trivial collisions (i.e. messages “00” and “000” would produce identical padded messages in the absence of L). The original message can be extracted by reading the last 64 for bits for length, and then fetching the message from left to right, of length l.</p>
        <ol>
                <li>Blocks. M’ is parsed into N blocks of size 512 bits, M¹ to Mᴺ, and each block is expressed as 16 input blocks of size 32 bits, M₀ to M₁₅.</li>
        </ol>
        <p align="center">
                <img src="https://github.com/Subham-Maity/Blockchain-Book-vol2/blob/master/Image%20Ignore/17.png?raw=true "  width="200px"/>
        </p>

        <p>Each block contains 16 input blocks, numbered from 0 to 15 in every block</p>
        <ol>
                <li>Hash initialization. The initial hash value H⁰ of length 256 bits (8 input blocks of 32 bits) is set by taking the first 32 bits of the fractional parts of the square roots of the first eight prime numbers:</li>
        </ol>
        <p align="center">
                <img src="https://github.com/Subham-Maity/Blockchain-Book-vol2/blob/master/Image%20Ignore/18.png?raw=true "  width="200px"/>
        </p>
        The eight input blocks of the initial has value H, in hexadecimal notation

        Those values can be reproduced with the below snippet in most browsers and Node ≥8.2.1 (ECMAScript 2017):

        <code>for (i of [2, 3, 5, 7, 11, 13, 17, 19]) {
                input_block = parseInt((Math.sqrt(i) % 1).toString(2).slice(2, 34), 2);
                console.log(input_block.toString(16), input_block.toString(2).padStart(32, &#39;0&#39;));
                }</code>

        <strong>Algorithm</strong>

        The hash is produced by processing each message block Mⁱ of M’ in order. For each of message block Mⁱ:

        1. Message schedule. We create a message schedule Wⁱ, consisting of four 512-bit message blocks (each made of 16 input blocks). The first block of Wⁱ is message block Mⁱ, and the next three blocks are variations of Mⁱ, obtained through the formulas in the illustration below:

        <p align="center">
                <img src="https://github.com/Subham-Maity/Blockchain-Book-vol2/blob/master/Image%20Ignore/19.png?raw=true "  width="200px"/>
        </p>

        <p>In the formulas, t refers to the ‘input block’ number, ranging from 0 to 63. The input blocks of the ‘shuffled blocks’ are functions of prior input blocks, and are generated with special functions, mixing right rotations (ROTR), right shifts (SHR) and exclusive ORs (⊕). Those operations are introduced in a previous article on Bitwise Patterns.</p>
        <p>A detail: note that if we align all message schedules Wⁱ vertically, the first column reads from top to bottom as the complete message M’ = M¹‖..‖Mᴺ.</p>
        <ol>
                <li>The big shuffle. The input blocks of message schedule W are fed, one after the other, to a function represented below as a graph. The graph takes as inputs a hash ωⁱ(t) and a message schedule input block Wⁱ(t), and outputs a hash ωⁱ(t+1). The initial hash ωⁱ(0) fed to the graph is the intermediate hash Hⁱ⁻¹: in the case of W¹, it’s H⁰ defined in the pre-processing step. ωⁱ(0) and Wⁱ(0) produce ωⁱ(1); in turn ωⁱ(1) and Wⁱ(1) produce ωⁱ(2), etc., until ωⁱ(63) is produced.</li>
        </ol>
        <p align="center">
                <img src="https://github.com/Subham-Maity/Blockchain-Book-vol2/blob/master/Image%20Ignore/12.gif?raw=true "  width="200px"/>
        </p>

        <p>A visual representation the transformations operated on H⁰ using input blocks from the message schedule W. The operation must be repeated 64 times until ω(63) is produced.</p>
        <p align="center">
                <img src="https://github.com/Subham-Maity/Blockchain-Book-vol2/blob/master/Image%20Ignore/20.png?raw=true "  width="200px"/>
        </p>

        <p>The official loop as seen in FIPS 180–4. a, .., h are initialized as Hi⁻¹(0), .., Hi⁻¹(7). Sigma0, Sigma1, Ch, and Maj are functions using AND, XOR and negations; K is a bit word with 64 input blocks.</p>
        <ol>
                <li>New hash. After all input blocks from Wⁱ have been used and we ω(63) has been created, we can create the new hash Hⁱ such that each input block of Hⁱ is the sum of the corresponding input block of Hⁱ⁻¹ plus the corresponding input block of ωⁱ(63):</li>
        </ol>
        <p>Hⁱ(j) = Hⁱ⁻¹(j) + ωⁱ(63)(j) where + is the addition modulo 2ⁿ</p>
        <p>If other message blocks Mⁱ remain, repeat the process (message schedule, big shuffle, creation of the new hash Hⁱ)</p>
        <p>If Wⁱ was the last message schedule, then Hⁱ = H is message M’s final hash or digest — its so very special fingerprint.</p>
        <p>This concludes the overview of SHA-256 as described in FIPS 180–4. A few closing thoughts:</p>
        <p>SHA-256 projects into B²⁵⁶, a space of ~1e77 possible values, which is lots of potential digests: a good thing that provides the intuition that collisions are unlikely
                That being said, we do not prove here that collisions are unlikely, we even know they exist given the surjective nature of the hashing function. We know however that (i) given a limited amount of things to hash, we’re unlikely to find collisions (ii) no collisions have been found to date for SHA-256.
                Finally, coding your own SHA-256 for production use is probably not a good idea…
                …but just for fun and education purposes, here is a version I wrote in JavaScript.</p>
        <pre><code class="lang-js">'use strict';

(function (shs) {

  const H0 = [
    <span class="hljs-number">0x6a09e667</span>, <span class="hljs-number">0xbb67ae85</span>, <span class="hljs-number">0x3c6ef372</span>, <span class="hljs-number">0xa54ff53a</span>, <span class="hljs-number">0x510e527f</span>, <span class="hljs-number">0x9b05688c</span>, <span class="hljs-number">0x1f83d9ab</span>, <span class="hljs-number">0x5be0cd19</span>,
  ];

  const K = [
    <span class="hljs-number">0x428a2f98</span>, <span class="hljs-number">0x71374491</span>, <span class="hljs-number">0xb5c0fbcf</span>, <span class="hljs-number">0xe9b5dba5</span>, <span class="hljs-number">0x3956c25b</span>, <span class="hljs-number">0x59f111f1</span>, <span class="hljs-number">0x923f82a4</span>, <span class="hljs-number">0xab1c5ed5</span>,
    <span class="hljs-number">0xd807aa98</span>, <span class="hljs-number">0x12835b01</span>, <span class="hljs-number">0x243185be</span>, <span class="hljs-number">0x550c7dc3</span>, <span class="hljs-number">0x72be5d74</span>, <span class="hljs-number">0x80deb1fe</span>, <span class="hljs-number">0x9bdc06a7</span>, <span class="hljs-number">0xc19bf174</span>,
    <span class="hljs-number">0xe49b69c1</span>, <span class="hljs-number">0xefbe4786</span>, <span class="hljs-number">0x0fc19dc6</span>, <span class="hljs-number">0x240ca1cc</span>, <span class="hljs-number">0x2de92c6f</span>, <span class="hljs-number">0x4a7484aa</span>, <span class="hljs-number">0x5cb0a9dc</span>, <span class="hljs-number">0x76f988da</span>,
    <span class="hljs-number">0x983e5152</span>, <span class="hljs-number">0xa831c66d</span>, <span class="hljs-number">0xb00327c8</span>, <span class="hljs-number">0xbf597fc7</span>, <span class="hljs-number">0xc6e00bf3</span>, <span class="hljs-number">0xd5a79147</span>, <span class="hljs-number">0x06ca6351</span>, <span class="hljs-number">0x14292967</span>,
    <span class="hljs-number">0x27b70a85</span>, <span class="hljs-number">0x2e1b2138</span>, <span class="hljs-number">0x4d2c6dfc</span>, <span class="hljs-number">0x53380d13</span>, <span class="hljs-number">0x650a7354</span>, <span class="hljs-number">0x766a0abb</span>, <span class="hljs-number">0x81c2c92e</span>, <span class="hljs-number">0x92722c85</span>,
    <span class="hljs-number">0xa2bfe8a1</span>, <span class="hljs-number">0xa81a664b</span>, <span class="hljs-number">0xc24b8b70</span>, <span class="hljs-number">0xc76c51a3</span>, <span class="hljs-number">0xd192e819</span>, <span class="hljs-number">0xd6990624</span>, <span class="hljs-number">0xf40e3585</span>, <span class="hljs-number">0x106aa070</span>,
    <span class="hljs-number">0x19a4c116</span>, <span class="hljs-number">0x1e376c08</span>, <span class="hljs-number">0x2748774c</span>, <span class="hljs-number">0x34b0bcb5</span>, <span class="hljs-number">0x391c0cb3</span>, <span class="hljs-number">0x4ed8aa4a</span>, <span class="hljs-number">0x5b9cca4f</span>, <span class="hljs-number">0x682e6ff3</span>,
    <span class="hljs-number">0x748f82ee</span>, <span class="hljs-number">0x78a5636f</span>, <span class="hljs-number">0x84c87814</span>, <span class="hljs-number">0x8cc70208</span>, <span class="hljs-number">0x90befffa</span>, <span class="hljs-number">0xa4506ceb</span>, <span class="hljs-number">0xbef9a3f7</span>, <span class="hljs-number">0xc67178f2</span>,
  ];

  <span class="hljs-comment">/**
   * Rotate to right
   * @param {number} x - An integer to be shifted right
   * @param {number} n - The number of bits by which to shift
   * @param {string} [w] - The bit notation width. Defaults to x.toString(2).length
   * @return {number} The shifted number
   */</span>
  function rotr(x, n, w) {
    if (!w) { var w = x.toString(<span class="hljs-number">2</span>).length; }
    n = n % w;
    return (((x &gt;&gt;&gt; n) | (x &lt;&lt; w - n)) &gt;&gt;&gt; <span class="hljs-number">0</span>) % Math.pow(<span class="hljs-number">2</span>, w);
  };

  <span class="hljs-comment">/**
   * Rotate to left
   * @param {number} x - An integer to be shifted right
   * @param {number} n - The number of bits by which to shift
   * @return {number} The shifted number
   */</span>
  function rotl(x, n) {
    let w = x.toString(<span class="hljs-number">2</span>).length;
    n = n % w;
    return (((x &lt;&lt; n) | (x &gt;&gt;&gt; w - n)) &gt;&gt;&gt; <span class="hljs-number">0</span>) % Math.pow(<span class="hljs-number">2</span>, w);
  };

  <span class="hljs-comment">/**
   * SHA-256 logical functions
   */</span>
  function Ch(x, y, z) { return (x &amp; y) ^ (~x &amp; z); };

  function Maj(x, y, z) { return (x &amp; y) ^ (x &amp; z) ^ (y &amp; z); };

  function Σ<span class="hljs-number">0</span>(x) { return rotr(x, <span class="hljs-number">2</span>, <span class="hljs-number">32</span>) ^ rotr(x, <span class="hljs-number">13</span>, <span class="hljs-number">32</span>) ^ rotr(x, <span class="hljs-number">22</span>, <span class="hljs-number">32</span>); };

  function Σ<span class="hljs-number">1</span>(x) { return rotr(x, <span class="hljs-number">6</span>, <span class="hljs-number">32</span>) ^ rotr(x, <span class="hljs-number">11</span>, <span class="hljs-number">32</span>) ^ rotr(x, <span class="hljs-number">25</span>, <span class="hljs-number">32</span>); };

  function σ<span class="hljs-number">0</span>(x) { return rotr(x, <span class="hljs-number">7</span>, <span class="hljs-number">32</span>) ^ rotr(x, <span class="hljs-number">18</span>, <span class="hljs-number">32</span>) ^ (x &gt;&gt;&gt; <span class="hljs-number">3</span>); };

  function σ<span class="hljs-number">1</span>(x) { return rotr(x, <span class="hljs-number">17</span>, <span class="hljs-number">32</span>) ^ rotr(x, <span class="hljs-number">19</span>, <span class="hljs-number">32</span>) ^ (x &gt;&gt;&gt; <span class="hljs-number">10</span>); };

  <span class="hljs-comment">/**
   * Padding
   * @param {string} m - The message, a binary string (e.g., 011010)
   * @return {string} A padded message
   */</span>
  function pad(m) {
    if (m.length &gt; Math.pow(<span class="hljs-number">2</span>, <span class="hljs-number">64</span>)) {
      return console.error('Message out of range.');
    }

    let padding1 = '<span class="hljs-number">0</span>'.repeat(<span class="hljs-number">512</span> - ((m.length + <span class="hljs-number">1</span> + <span class="hljs-number">64</span>) % <span class="hljs-number">512</span>));
    let padding2 = '<span class="hljs-number">0</span>'.repeat(<span class="hljs-number">64</span> - m.length.toString(<span class="hljs-number">2</span>).length);
    return `${m}<span class="hljs-number">1</span>${padding1}${padding2}${m.length.toString(<span class="hljs-number">2</span>)}`;
  }

  <span class="hljs-comment">/**
   * Parse
   * @param {string} paddedMessage - A padded message of length N x 512
   * @return {array} An array containing 512 segments, further split in 32-bit segments
   * expressed as numbers
   */</span>
  function parse(m) {
    let M = m.match(/[<span class="hljs-number">0</span><span class="hljs-number">-1</span>]{<span class="hljs-number">512</span>}/g);

    return M.map((x) =&gt; {
      let arr = x.match(/[<span class="hljs-number">0</span><span class="hljs-number">-1</span>]{<span class="hljs-number">32</span>}/g);
      return arr.map((x) =&gt; {
        return parseInt(x, <span class="hljs-number">2</span>);
      });
    });
  };

  <span class="hljs-comment">/**
   * Hash
   * @param {string} m - A binary string to be hashed
   * @return {string} A SHA-256 digest
   */</span>
  shs.hash = function (m) {

    <span class="hljs-comment">// Pre-processing</span>
    let M = parse(pad(m));

    <span class="hljs-comment">// Initialize the hash</span>
    let H = [H0];

    <span class="hljs-comment">// Hash computation</span>
    for (let i = <span class="hljs-number">0</span>, N = M.length; i &lt; N; i++) {

      <span class="hljs-comment">// Prepare the message schedule</span>
      let W = [];
      for (let t = <span class="hljs-number">0</span>; t &lt; <span class="hljs-number">64</span>; t++) {
        if (t &lt;= <span class="hljs-number">15</span>) {
          W[t] = M[i][t];
        } else {
          W[t] = (σ<span class="hljs-number">1</span>(W[t - <span class="hljs-number">2</span>]) + W[t - <span class="hljs-number">7</span>] + σ<span class="hljs-number">0</span>(W[t - <span class="hljs-number">15</span>]) + W[t - <span class="hljs-number">16</span>]) % Math.pow(<span class="hljs-number">2</span>, <span class="hljs-number">32</span>);
        }
      }

      <span class="hljs-comment">// Initialize the working variables</span>
      let a = H[i][<span class="hljs-number">0</span>];
      let b = H[i][<span class="hljs-number">1</span>];
      let c = H[i][<span class="hljs-number">2</span>];
      let d = H[i][<span class="hljs-number">3</span>];
      let e = H[i][<span class="hljs-number">4</span>];
      let f = H[i][<span class="hljs-number">5</span>];
      let g = H[i][<span class="hljs-number">6</span>];
      let h = H[i][<span class="hljs-number">7</span>];
      let T1;
      let T2;

      <span class="hljs-comment">// Do stuff</span>
      for (let t = <span class="hljs-number">0</span>; t &lt; <span class="hljs-number">64</span>; t++) {
        T1 = (h + Σ<span class="hljs-number">1</span>(e) + Ch(e, f, g) + K[t] + W[t]) % Math.pow(<span class="hljs-number">2</span>, <span class="hljs-number">32</span>);
        T2 = (Σ<span class="hljs-number">0</span>(a) + Maj(a, b, c)) % Math.pow(<span class="hljs-number">2</span>, <span class="hljs-number">32</span>);
        h = g;
        g = f;
        f = e;
        e = (d + T1) % Math.pow(<span class="hljs-number">2</span>, <span class="hljs-number">32</span>);
        d = c;
        c = b;
        b = a;
        a = (T1 + T2) % Math.pow(<span class="hljs-number">2</span>, <span class="hljs-number">32</span>);
      }

      <span class="hljs-comment">// Compute the i-th intermediate hash</span>
      H[i + <span class="hljs-number">1</span>] = [];
      H[i + <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = (a + H[i][<span class="hljs-number">0</span>]) % Math.pow(<span class="hljs-number">2</span>, <span class="hljs-number">32</span>);
      H[i + <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = (b + H[i][<span class="hljs-number">1</span>]) % Math.pow(<span class="hljs-number">2</span>, <span class="hljs-number">32</span>);
      H[i + <span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = (c + H[i][<span class="hljs-number">2</span>]) % Math.pow(<span class="hljs-number">2</span>, <span class="hljs-number">32</span>);
      H[i + <span class="hljs-number">1</span>][<span class="hljs-number">3</span>] = (d + H[i][<span class="hljs-number">3</span>]) % Math.pow(<span class="hljs-number">2</span>, <span class="hljs-number">32</span>);
      H[i + <span class="hljs-number">1</span>][<span class="hljs-number">4</span>] = (e + H[i][<span class="hljs-number">4</span>]) % Math.pow(<span class="hljs-number">2</span>, <span class="hljs-number">32</span>);
      H[i + <span class="hljs-number">1</span>][<span class="hljs-number">5</span>] = (f + H[i][<span class="hljs-number">5</span>]) % Math.pow(<span class="hljs-number">2</span>, <span class="hljs-number">32</span>);
      H[i + <span class="hljs-number">1</span>][<span class="hljs-number">6</span>] = (g + H[i][<span class="hljs-number">6</span>]) % Math.pow(<span class="hljs-number">2</span>, <span class="hljs-number">32</span>);
      H[i + <span class="hljs-number">1</span>][<span class="hljs-number">7</span>] = (h + H[i][<span class="hljs-number">7</span>]) % Math.pow(<span class="hljs-number">2</span>, <span class="hljs-number">32</span>);
    }

    let digestWords = H[M.length];
    let digestTemp = digestWords.map((x) =&gt; {
      let hex = (x &gt;&gt;&gt; <span class="hljs-number">0</span>).toString(<span class="hljs-number">16</span>);
      return `${'<span class="hljs-number">0</span>'.repeat(<span class="hljs-number">8</span> - hex.length)}${hex}`;
    });

    let digest = digestTemp.join('');
    return digest;
  };

  <span class="hljs-comment">/**
   * Hash a UTF-8 string
   * @param {string} string - A string, encoded using UTF-8
   * @return {string} A SHA-256 digest
   */</span>
  shs.hashString = function (str) {
    return shs.hash(helpers.toUTF8OctetString(str).replace(/ /g, '')); <span class="hljs-comment">// remove whitespqces</span>
  }

}(window.shs = window.shs || {}));
</code></pre>
        <pre><code class="lang-js"><span class="hljs-meta">'use strict'</span>;

(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">helpers</span>) </span>{

  <span class="hljs-comment">/**
   * Converts binary code point into a UTF-8 binary string
   * @param {number} codepoint - A Unicode codepoint as a number
   * @return {string} The UTF-8 binary string for that codepoint
   */</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">codePointToUtf8BinaryNotation</span>(<span class="hljs-params">codePoint</span>) </span>{

    <span class="hljs-keyword">const</span> str = codePoint.toString(<span class="hljs-number">2</span>);
    <span class="hljs-keyword">const</span> len = str.length;

    <span class="hljs-comment">// 0xxxxxxx</span>
    <span class="hljs-keyword">if</span> (len &lt;= <span class="hljs-number">7</span>) {
      <span class="hljs-keyword">let</span> padding = <span class="hljs-string">'0'</span>.repeat(<span class="hljs-number">7</span> - len);
      <span class="hljs-keyword">return</span> <span class="hljs-string">`0<span class="hljs-subst">${padding}</span><span class="hljs-subst">${str}</span>`</span>;
    }

    <span class="hljs-comment">// 110xxxxx 10xxxxxx</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len &lt;= <span class="hljs-number">11</span>) {
      <span class="hljs-keyword">let</span> padding = <span class="hljs-string">'0'</span>.repeat(<span class="hljs-number">11</span> - len);
      <span class="hljs-keyword">return</span> <span class="hljs-string">`110<span class="hljs-subst">${padding}</span><span class="hljs-subst">${str.slice(<span class="hljs-number">0</span>, <span class="hljs-number">-6</span>)}</span> 10<span class="hljs-subst">${str.slice(<span class="hljs-number">-6</span>)}</span>`</span>;
    }

    <span class="hljs-comment">// 1110xxxx 10xxxxxx 10xxxxxx</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len &lt;= <span class="hljs-number">16</span>) {
      <span class="hljs-keyword">let</span> padding = <span class="hljs-string">'0'</span>.repeat(<span class="hljs-number">16</span> - len);
      <span class="hljs-keyword">return</span> <span class="hljs-string">`1110<span class="hljs-subst">${padding}</span><span class="hljs-subst">${str.slice(<span class="hljs-number">0</span>, <span class="hljs-number">-12</span>)}</span> 10<span class="hljs-subst">${str.slice(<span class="hljs-number">-12</span>, <span class="hljs-number">-6</span>)}</span> 10<span class="hljs-subst">${str.slice(<span class="hljs-number">-6</span>)}</span>`</span>;
    }

    <span class="hljs-comment">// 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len &lt;= <span class="hljs-number">21</span>) {

      <span class="hljs-comment">// Special case where bits can still fit in the last 3 octets</span>
      <span class="hljs-keyword">if</span> (len == <span class="hljs-number">17</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-string">`11110000 100<span class="hljs-subst">${str.slice(<span class="hljs-number">0</span>, <span class="hljs-number">-12</span>)}</span> 10<span class="hljs-subst">${str.slice(<span class="hljs-number">-12</span>, <span class="hljs-number">-6</span>)}</span> 10<span class="hljs-subst">${str.slice(<span class="hljs-number">-6</span>)}</span>`</span>;
      }

      <span class="hljs-keyword">let</span> padding = <span class="hljs-string">'0'</span>.repeat(<span class="hljs-number">21</span> - len);
      <span class="hljs-keyword">return</span> <span class="hljs-string">`11110<span class="hljs-subst">${padding}</span><span class="hljs-subst">${str.slice(<span class="hljs-number">0</span>, <span class="hljs-number">-18</span>)}</span> 10<span class="hljs-subst">${str.slice(<span class="hljs-number">-18</span>, <span class="hljs-number">-12</span>)}</span> 10<span class="hljs-subst">${str.slice(<span class="hljs-number">-12</span>, <span class="hljs-number">-6</span>)}</span> 10<span class="hljs-subst">${str.slice(<span class="hljs-number">-6</span>)}</span>`</span>;
    }

    <span class="hljs-comment">// Error</span>
    <span class="hljs-keyword">else</span> {
      <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'Did not receive a valid Unicode binaryNotation'</span>);
    }

  };

  <span class="hljs-comment">/**
   * Converts a human-readble string into a UTF-8 binary string
   * @param {string} str - A human-readable string
   * @return {string} An octet string
   */</span>
  helpers.toUTF8OctetString = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">str</span>) </span>{
    <span class="hljs-keyword">let</span> octetStringArray = [];

    <span class="hljs-comment">// Use for..of to avoid counting of surrogate pairs</span>
    <span class="hljs-comment">// see: https://mathiasbynens.be/notes/javascript-unicode</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> symbol <span class="hljs-keyword">of</span> str) {

      <span class="hljs-keyword">let</span> codePoint = symbol.codePointAt(<span class="hljs-number">0</span>);
      <span class="hljs-keyword">let</span> utf8BinaryNotation = codePointToUtf8BinaryNotation(codePoint);

      octetStringArray.push(utf8BinaryNotation);
    };

    <span class="hljs-keyword">return</span> octetStringArray.join(<span class="hljs-string">' '</span>);

  };

  <span class="hljs-comment">/**
   * Converts a UTF-8 octet string in human-readable formate
   * @param {string} str - A UTF-8 octet string in binary format
   * @return {string} A human-readable string
   */</span>
  helpers.fromUTF8OctetString = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">str</span>) </span>{
    <span class="hljs-keyword">let</span> octetStringArray = str.split(<span class="hljs-string">' '</span>);
    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> output = [];

    <span class="hljs-keyword">while</span> (i &lt; octetStringArray.length) {

      <span class="hljs-comment">// 0xxxxxxx</span>
      <span class="hljs-keyword">if</span> (octetStringArray[i].slice(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>) == <span class="hljs-string">'0'</span>) {
        <span class="hljs-keyword">let</span> codeUnit = octetStringArray.slice(i, i + <span class="hljs-number">1</span>).join(<span class="hljs-string">' '</span>);
        <span class="hljs-keyword">let</span> codePointBin = codeUnit.slice(<span class="hljs-number">1</span>);
        <span class="hljs-keyword">let</span> codePoint = <span class="hljs-built_in">parseInt</span>(codePointBin, <span class="hljs-number">2</span>);
        output.push(<span class="hljs-built_in">String</span>.fromCodePoint(codePoint));
        i += <span class="hljs-number">1</span>;
      }

      <span class="hljs-comment">// 110xxxxx 10xxxxxx</span>
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (octetStringArray[i].slice(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>) == <span class="hljs-string">'110'</span>) {
        <span class="hljs-keyword">let</span> codeUnit = octetStringArray.slice(i, i + <span class="hljs-number">2</span>).join(<span class="hljs-string">' '</span>);
        <span class="hljs-keyword">let</span> codePointBin = <span class="hljs-string">`<span class="hljs-subst">${codeUnit.slice(<span class="hljs-number">3</span>, <span class="hljs-number">8</span>)}</span><span class="hljs-subst">${codeUnit.slice(<span class="hljs-number">11</span>)}</span>`</span>;
        <span class="hljs-keyword">let</span> codePoint = <span class="hljs-built_in">parseInt</span>(codePointBin, <span class="hljs-number">2</span>);
        output.push(<span class="hljs-built_in">String</span>.fromCodePoint(codePoint));
        i += <span class="hljs-number">2</span>;
      }

      <span class="hljs-comment">// 1110xxxx 10xxxxxx 10xxxxxx</span>
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (octetStringArray[i].slice(<span class="hljs-number">0</span>, <span class="hljs-number">4</span>) == <span class="hljs-string">'1110'</span>) {
        <span class="hljs-keyword">let</span> codeUnit = octetStringArray.slice(i, i + <span class="hljs-number">3</span>).join(<span class="hljs-string">' '</span>);
        <span class="hljs-keyword">let</span> codePointBin = <span class="hljs-string">`<span class="hljs-subst">${codeUnit.slice(<span class="hljs-number">4</span>, <span class="hljs-number">8</span>)}</span><span class="hljs-subst">${codeUnit.slice(<span class="hljs-number">11</span>, <span class="hljs-number">17</span>)}</span><span class="hljs-subst">${codeUnit.slice(<span class="hljs-number">20</span>)}</span>`</span>;
        <span class="hljs-keyword">let</span> codePoint = <span class="hljs-built_in">parseInt</span>(codePointBin, <span class="hljs-number">2</span>);
        output.push(<span class="hljs-built_in">String</span>.fromCodePoint(codePoint));
        i += <span class="hljs-number">3</span>;
      }

      <span class="hljs-comment">// 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</span>
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (octetStringArray[i].slice(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>) == <span class="hljs-string">'11110'</span>) {
        <span class="hljs-keyword">let</span> codeUnit = octetStringArray.slice(i, i + <span class="hljs-number">4</span>).join(<span class="hljs-string">' '</span>);
        <span class="hljs-keyword">let</span> codePointBin = <span class="hljs-string">`<span class="hljs-subst">${codeUnit.slice(<span class="hljs-number">4</span>, <span class="hljs-number">8</span>)}</span><span class="hljs-subst">${codeUnit.slice(<span class="hljs-number">11</span>, <span class="hljs-number">17</span>)}</span><span class="hljs-subst">${codeUnit.slice(<span class="hljs-number">20</span>, <span class="hljs-number">26</span>)}</span><span class="hljs-subst">${codeUnit.slice(<span class="hljs-number">29</span>)}</span>`</span>;
        <span class="hljs-keyword">let</span> codePoint = <span class="hljs-built_in">parseInt</span>(codePointBin, <span class="hljs-number">2</span>);
        output.push(<span class="hljs-built_in">String</span>.fromCodePoint(codePoint));
        i += <span class="hljs-number">4</span>;
      }

      <span class="hljs-comment">// Else, there is an error</span>
      <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'Unexpected UTF-8 octet'</span>);
      }

    }

    <span class="hljs-keyword">return</span> output.join(<span class="hljs-string">''</span>);
  };


}(<span class="hljs-built_in">window</span>.helpers = <span class="hljs-built_in">window</span>.helpers || {}));
</code></pre>

</div>


</body>
</html>


